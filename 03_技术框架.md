# Clerk Auth

github account login

[API KEY](https://dashboard.clerk.com/apps/app_2h3rVTIOKEjDPMvkButuenB43ro/instances/ins_2h3rVayUgo9oHxXrn0Wi3DaLVqX/api-keys)设置到 env 中<br/>
![alt text](99_screenshot/clerk_config.png)

# DB

[neon postgresql](https://console.neon.tech/app/projects/billowing-unit-66449389?database=metube)<br/>
![alt text](99_screenshot/db_config.png)

# drizzle

Drizzle 是一个现代的 TypeScript 优先 的 ORM（对象关系映射）工具，它诞生是为了解决以下几个数据库开发中的痛点：<br/>
![alt text](99_screenshot/drizzle_why.png)

drizzle sample<br/>
![alt text](99_screenshot/drizzle_sample.png)

drizzle vs prisma<br/>
![alt text](99_screenshot/drizzle_vs_prisma.png)

## Drizzle vs Prisma 对比表

| 特性               | 🧪 Drizzle ORM                             | 🌈 Prisma ORM                               |
| ------------------ | ------------------------------------------ | ------------------------------------------- |
| **语言风格**       | TypeScript-first，显式代码                 | Schema-first，使用 Prisma 自定义 DSL        |
| **SQL 可见性**     | ✅ 显式构建 SQL，SQL 语义可读              | ❌ 自动生成查询，SQL 不可见                 |
| **类型安全**       | ✅ 完全类型安全，推导到字段级              | ✅ 查询结果类型安全（但 SQL 构建不透明）    |
| **迁移机制**       | ✅ 代码即 schema，强一致性                 | ❌ 需要额外维护 `.prisma` schema 和迁移文件 |
| **运行时依赖**     | ❌ 无运行时魔法或生成器                    | ✅ 依赖代码生成器和运行时客户端             |
| **学习曲线**       | ✅ 熟悉 SQL 就能用                         | ⛔ 需要学习 Prisma schema DSL               |
| **调试体验**       | ✅ SQL 可见，易调试                        | ❌ SQL 隐藏，调试需依赖日志                 |
| **性能开销**       | ✅ 极轻量、无 ORM 中间层                   | ⛔ Prisma Client 较重，可能影响冷启动       |
| **使用环境兼容性** | ✅ 支持 Edge Functions、Bun、Serverless    | ❌ 在某些 Edge 环境中运行不稳定             |
| **数据库支持**     | PostgreSQL、MySQL、SQLite（计划支持更多）  | PostgreSQL、MySQL、SQLite、MongoDB 等       |
| **社区与生态**     | 新兴中，轻量级方向                         | 成熟、生态丰富                              |
| **适合人群**       | 注重性能、喜欢 SQL、重视类型一致性的开发者 | 追求开发效率、自动化、企业项目              |

## Get Start

neon postgresql:https://orm.drizzle.team/docs/get-started/neon-new
<br/>
local postgresql:https://orm.drizzle.team/docs/get-started/postgresql-new

## 推送数据库表

1. 在 db 文件夹中完成下面三个基础文件创建。<br/>
   drizzle.config.ts<br/>
   src\db\index.ts<br/>
   src\db\schema.ts<br/>
2. 通过 drizzle-kit 命令包中的 push 命令，推送 Table 到数据库中。<br/>
   bunx drizzle-kit push

```bash
PS D:\02_ALL_WORKSPACE\reactWK\nextjs-study\next15-youtube-clone> bunx drizzle-kit push
No config path provided, using default 'drizzle.config.ts'
Reading config file 'D:\02_ALL_WORKSPACE\reactWK\nextjs-study\next15-youtube-clone\drizzle.config.ts'Using '@neondatabase/serverless' driver for database querying
 Warning  '@neondatabase/serverless' can only connect to remote Neon/Vercel Postgres/Supabase instances through a websocket
[✓] Pulling schema from database...
[✓] Changes applied
```

推送完成后去数据库确认表创建成功<br/>
![alt text](99_screenshot/drizzle_kit_push_table_users.png)

完成 drizzle 的表推送后，也可以通过 drizzle 的 studio 客户端打开数据库。

```bash
bunx drizzle-kit studio
```

# Webhook Sync

Webhook Sync 的诞生是为了替代低效的轮询模式，通过事件驱动模式实现——仅在数据变化时主动推送（Push），避免无效查询。

Webhook Sync 解决的核心问题：<br/>
(1) 实时性需求<br/>
场景：支付成功通知、订单状态更新、GitHub 代码推送等。<br/>
方案：服务方（如支付系统）通过 Webhook 立即 将事件推送给订阅方，实现秒级同步。

(2) 系统解耦<br/>
问题：紧耦合系统（如直接 API 调用）会因依赖方故障引发连锁反应。<br/>
方案：Webhook 通过 HTTP 回调通知，发送方和接收方完全解耦，仅需约定消息格式。

(3) 降低服务器压力<br/>
对比轮询：1000 个客户端轮询 1 次/秒 → 每秒 1000 次请求。<br/>
Webhook 模式：只有事件发生时触发，可能全天仅需 10 次请求。<br/>

## [ngrok](https://dashboard.ngrok.com/get-started/setup/windows)

因为第三方服务（如：clerk）无法直接发送请求到我们的 localhost 上，只能发送请求到一个对外公布的域名。<br/>
因此需要通过下面步骤建立一个静态域名映射，便于将 webhook 的请求转发给 localhost

1. choco install ngrok 在 windows 上会因为杀毒软件导致 access error，建议直接在上面官网下载 ngrok.exe，打开 ngrok.exe 文件弹出 cmd 对话框。<br/>
   D:\03_software\ngrok-v3-stable-windows-amd64\ngrok.exe
2. 按照官网 step2 配置 ngrok config add-authtoken，<br/>
   文件路径：C:\Users\Zhupeng\AppData\Local/ngrok/ngrok.yml。
3. bun run dev,默认 port 应该是 3000
4. 建立域名与 localhost300 的映射:<br/>
   ngrok http --url=tightly-prompt-halibut.ngrok-free.app 3000
   <br/>如果上面的命令运行错误，试试把--url 改成--domain
   ![alt text](99_screenshot/ngrok_connect.png)

## [clerk webhook](https://dashboard.clerk.com/apps/app_2h3rVTIOKEjDPMvkButuenB43ro/instances/ins_2h3rVayUgo9oHxXrn0Wi3DaLVqX/webhooks)

1. 新建一个 webhook endpoint<br/>
   ![alt text](99_screenshot/clerk_webhook_create.png)
2. 把 Signing Secret 设置到 env 中
   ![alt text](99_screenshot/clerk_webhook_signing_secret.png)

## Svix

Svix 的诞生是为了解决 企业级 Webhook 可靠性和规模化 的核心问题。以下是其核心定位和解决的痛点：<br/>

### 原生 Webhook 的局限性

开发者直接使用 Webhook 时面临的主要挑战：

1. 可靠性差：接收方服务宕机或网络波动会导致消息丢失。
2. 缺乏可观测性：无法追踪 Webhook 的送达状态、重试历史。
3. 安全风险：伪造请求（如中间人攻击）、签名验证复杂。
4. 规模化困难：高并发下自建 Webhook 系统难以保证性能和顺序性。
